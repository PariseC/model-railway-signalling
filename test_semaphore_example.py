#----------------------------------------------------------------------
# This programme provides a simple example of how to use the "points"
# and "signals" modules, with the tkinter graphics library to create a
# track schematic with a couple of points, add signals and then apply
# a basic "interlocking" scheme. For a more complicated example (with
# "track circuits", automatic signals and route displays see "my_layout"
# ---------------------------------------------------------------------

from tkinter import *
from model_railway_signals import *
import logging

#----------------------------------------------------------------------
# Here is where we configure the logging - to see what's going on 
#----------------------------------------------------------------------

# Here we configure logging to report the log level and the associated log message
# generated by the code. If you include ':%(funcName)s' in the format string then
# the log message will additionally tell you the function that generated the message
# The default level (no 'level' specified) will provide just warnings and errors
# A level of 'INFO' will tell you what the various 'model_railway_signalling' functions
# are doing 'under the hood' - useful when developing/debugging a layout signalling
# A level of 'DEBUG' will additionally report the DCC Bus commands being sent to the Pi-SPROG
logging.basicConfig(format='%(levelname)s: %(message)s',level=logging.DEBUG) 

# There is an additional level of debug logging that can be enabled for the Pi-SPROG interface
# This will show the actual 'CBUS Grid Connect' protocol commands being sent and received
# Useful for comparing with the console output in the JMRI application for advanced debugging
# Note that the main logging level also needs to be set to DEBUG to generate these messages
debug_dcc = False

#----------------------------------------------------------------------
# This is the main callback function for when something changes
# i.e. a point or signal "button" has been clicked on the display
#----------------------------------------------------------------------

def main_callback_function(item_id,callback_type):

    #--------------------------------------------------------------
    # Deal with changes to the Track Occupancy
    #--------------------------------------------------------------

    # If its an external track sensor event then pulse the associated "signal passed"
    # button - Here we use a straightforward 1-1 mapping as we gave our sensors the
    # same IDs as their associated signals when we created them
    if callback_type == track_sensor_callback_type.sensor_triggered:
        pulse_signal_passed_button(item_id)
        
    # Now deal with the track occupancy
    if (callback_type == sig_callback_type.sig_passed
           or callback_type == track_sensor_callback_type.sensor_triggered):
        if item_id == 1:
            set_section_occupied(1)
        elif item_id == 2:
            clear_section_occupied(1)
            if point_switched(1):
                set_section_occupied(2)
            else:
                set_section_occupied(3)
        elif item_id == 3:
            clear_section_occupied(2)
            set_section_occupied(4)
        elif item_id == 4:
            clear_section_occupied(3)
            set_section_occupied(4)
        elif item_id == 5:
            trigger_timed_signal (5,0,3)
            clear_section_occupied(4)
            
    #--------------------------------------------------------------
    # Override signals based on track occupancy - we could use
    # the signal passed events to do this but we also need to
    # allow for manual setting/resetting the track occupancy sections
    #--------------------------------------------------------------
    
    if ((section_occupied(2) and point_switched(1)) or
            (section_occupied(3) and not point_switched(1))):
        set_signal_override(2)
        set_signal_override(1)
    elif section_occupied(1):
        clear_signal_override(2)
        set_signal_override(1)
    else:
        clear_signal_override(2)
        clear_signal_override(1)

    if section_occupied(4):
        set_signal_override(3)
        set_signal_override(4)
    else:
        clear_signal_override(3)
        clear_signal_override(4)
    
    #--------------------------------------------------------------
    # Update the route based on the point settings 
    #--------------------------------------------------------------
    
    if point_switched(1):
        set_route(1,route=route_type.LH1)
        set_route(2,route=route_type.LH1)
    else:
        set_route(1,route=route_type.MAIN)
        set_route(2,route=route_type.MAIN)

    #-------------------------------------------------------------- 
    # Process the signal/point interlocking
    #--------------------------------------------------------------
    
    # Signal 1 is locked (at danger) if the signal 1 is at Danger and Signal 2 is at Danger
    # We do it this way as nothing should prevent signals from being returned to Danger
    if not signal_clear(1) and not signal_clear(2):
        lock_signal(1)
    else:
        unlock_signal(1)
    # Signal 2 is locked (at danger) if the point 1 facing point lock is not active
    # There is only a subsidary arm for the LH divergent route so we also need to
    # lock the subsidary signal if point 1 is set for the main route
    if not fpl_active(1):
        lock_signal(2)
        lock_subsidary(2)
    elif not point_switched(1):
        unlock_signal(2)
        lock_subsidary(2)
    else:
        if subsidary_clear(2): lock_signal(2)
        else: unlock_signal(2)
        if signal_clear(2): lock_subsidary(2)
        else: unlock_subsidary(2)
    # Signal 3 is locked (at danger) if point 2 is set against it 
    if not point_switched(2):
        lock_signal(3)
    else:
        unlock_signal(3)
    # Signal 4 is locked (at danger) if point 2 is set against it 
    if point_switched(2):
        lock_signal(4)
    else:
        unlock_signal(4)
    # Point 1 is locked if signal 1, signal 2 (or its subsidary) is set to clear
    if signal_clear(1) or signal_clear(2) or subsidary_clear(2):
        lock_point(1)
    else:
        unlock_point(1)
    # Point 2 is locked if either signals 3 or 4 are set to clear
    if signal_clear(3) or signal_clear(4):
        lock_point(2)
    else:
        unlock_point(2)
        
    return()

#------------------------------------------------------------------------------------
# This is where the code begins
#------------------------------------------------------------------------------------

# Create the Window and canvas
print ("Creating Window and Canvas")
window = Tk()
window.title("Simple Interlocking Example - with Semaphores")
canvas = Canvas(window,height=400,width=1000,bg="grey85")
canvas.pack()

# Initialise the Pi-SPROG-3 and define the DCC mappings for the signals and points we are
# going to create (if not running on a Pi-SPROG this will generate an error message, but
# the software will still work albeit without sending any DCC Commands to the Pi-SPROG)
# Mappings should be created first so that when the signals and points are created then
# the appropriate DCC bus commands will be sent to set the initial aspects correctly

print ("Initialising Pi Sprog and creating DCC Mappings")
initialise_pi_sprog (dcc_debug_mode=debug_dcc)
request_dcc_power_on()

# Simple mapping of the main signal to a single DCC address
map_semaphore_signal (sig_id = 1, main_signal = 1 , left_signal = 10 )
map_semaphore_signal (sig_id = 2, main_signal = 2 , left_signal = 11 , left_subsidary = 12)
map_semaphore_signal (sig_id = 3, main_signal = 3 )
map_semaphore_signal (sig_id = 4, main_signal = 4 )
map_semaphore_signal (sig_id = 5, main_signal = 5 )

# Points are simply mapped to single addresses
map_dcc_point (1, 100)
map_dcc_point (2, 101)

print ("Drawing Schematic and creating points")
# Draw the the Main line (up to the first point)
canvas.create_line(0,200,350,200,fill="black",width=3) 
# Create (and draw) the first point - a left hand point with a Facing Point Lock
# The "callback" is the name of the function (above) that will be called when something has changed
create_point(canvas,1,point_type.LH, 375,200,"black",point_callback=main_callback_function,fpl=True) 
# Draw the Main Line and Loop Line
canvas.create_line(375,175,400,150,fill="black",width=3) # 45 degree line from point to start of loop
canvas.create_line(400,150,675,150,fill="black",width=3) # Loop line
canvas.create_line(400,200,675,200,fill="black",width=3) # Main Line
canvas.create_line(675,150,700,175,fill="black",width=3) # 45 degree line from end of loop to second point
# Create (and draw) the second point - a right hand point rotated by 180 degrees
# No facing point lock needed for this point as direction of travel is left to right
create_point(canvas,2,point_type.RH, 700,200,"black",
                    point_callback=main_callback_function,orientation=180) 
# Draw the continuation of the Main Line 
canvas.create_line(725,200,1000,200,fill="black",width=3) # 45 degree line from point to start of loop

# Create the track occupancy sections
print ("Creating the track Occupancy Sections")
create_section(canvas,1,175,200,section_callback=main_callback_function)
create_section(canvas,2,500,150,section_callback=main_callback_function)
create_section(canvas,3,500,200,section_callback=main_callback_function)
create_section(canvas,4,800,200,section_callback=main_callback_function)

# Create the Signals on the Schematic track plan
# The "callback" is the name of the function (above) that will be called when something has changed
# Signal 2 is the signal just before the point - so it needs a route indication
print ("Creating Signals")
create_semaphore_signal (canvas,1,50,200,distant = True,
                         sig_callback=main_callback_function,
                         lhroute1 = True,
                         sig_passed_button = True)
create_semaphore_signal (canvas,2,275,200,
                         sig_callback=main_callback_function,
                         subsidarylh1 = True,
                         lhroute1 = True,
                         sig_passed_button = True)
create_semaphore_signal (canvas,3,600,150,
                         sig_callback=main_callback_function,
                         sig_passed_button = True)
create_semaphore_signal (canvas,4,600,200,
                         sig_callback=main_callback_function,
                         sig_passed_button = True)
create_semaphore_signal (canvas,5,900,200,
                         sig_callback=main_callback_function,
                         sig_passed_button=True)

# Map external track sensors for the signals - For simplicity, we'll give them the same ID as the signal
print ("Creating external Track Sensor Mappings")
create_track_sensor (1, gpio_channel = 4,
                    sensor_callback = main_callback_function,
                    sensor_timeout = 3.0)
create_track_sensor (2, gpio_channel = 5,
                    sensor_callback = main_callback_function,
                    sensor_timeout = 3.0)
create_track_sensor (3, gpio_channel = 6,
                    sensor_callback = main_callback_function,
                    sensor_timeout = 3.0)
create_track_sensor (4, gpio_channel = 7,
                    sensor_callback = main_callback_function,
                    sensor_timeout = 3.0)
create_track_sensor (5, gpio_channel = 8,
                    sensor_callback = main_callback_function,
                    sensor_timeout = 3.0)

# Set the initial interlocking conditions - in this case lock signal 3 as point 2 is set against it
print ("Setting Initial Route and Interlocking")
lock_signal(1)
lock_signal(3)
lock_subsidary(2)
set_route (2,route_type.MAIN)
set_route (1,route_type.MAIN)

# Now enter the main event loop and wait for a button press (which will trigger a callback)
print ("Entering Main Event Loop")
window.mainloop()

#----------------------------------------------------------------------
# This programme provides a simple example of how to use the "points"
# and "signals" modules, with the tkinter graphics library to create a
# track schematic with a couple of points, add signals and then apply
# a basic "interlocking" scheme. For a more complicated example (with
# "track circuits", automatic signals and route displays see "my_layout"
# ---------------------------------------------------------------------

from tkinter import *
from model_railway_signals import *
import logging

#----------------------------------------------------------------------
# Here is where we configure the logging - to see what's going on 
#----------------------------------------------------------------------

# Here we configure logging to report the log level and the associated log message
# generated by the code. If you include ':%(funcName)s' in the format string then
# the log message will additionally tell you the function that generated the message
# The default level (no 'level' specified) will provide just warnings and errors
# A level of 'INFO' will tell you what the various 'model_railway_signalling' functions
# are doing 'under the hood' - useful when developing/debugging a layout signalling
# A level of 'DEBUG' will additionally report the DCC Bus commands being sent to the Pi-SPROG
logging.basicConfig(format='%(levelname)s: %(message)s',level=logging.DEBUG) 

#----------------------------------------------------------------------
# This is the main callback function for when something changes
# i.e. a point or signal "button" has been clicked on the display
# Note the optional "external_node" parameter to enable us to use
# the same function for handling external events from the mqtt broker
#----------------------------------------------------------------------

def main_callback_function(item_id,callback_type):

    print ("Callback into main program - Item: "+str(item_id)+" - Callback Type: "+str(callback_type))
    #--------------------------------------------------------------
    # Deal with changes to the Track Occupancy
    #--------------------------------------------------------------
        
    # First deal with the track occupancy
    if (callback_type == sig_callback_type.sig_passed):
        if item_id == 1:
            set_section_occupied(1)
        elif item_id == 2:
            clear_section_occupied(1)
            set_section_occupied(2)
        elif item_id == 3:
            clear_section_occupied(2)
            set_section_occupied(3)
        elif item_id == 4:
            clear_section_occupied(3)
            set_section_occupied(4)
        elif item_id == 5 and node=="Box1":
            clear_section_occupied(4)
            trigger_timed_signal(5,0,3)
            
    #--------------------------------------------------------------
    # Override signals based on track occupancy - we could use
    # the signal passed events to do this but we also need to
    # allow for manual setting/resetting the track occupancy sections
    #--------------------------------------------------------------
    
    if section_occupied(1):
        set_signal_override(1)
    else:
        clear_signal_override(1)
    if section_occupied(2):
        set_signal_override(2)
    else:
        clear_signal_override(2)
    if section_occupied(3):
        set_signal_override(3)
    else:
        clear_signal_override(3)
    if section_occupied(4):
        set_signal_override(4)
    else:
        clear_signal_override(4)

    #--------------------------------------------------------------
    # Refresh the signal aspects based on the route settings
    # The order is important - Need to work back along the route
    #--------------------------------------------------------------
    update_signal(4, sig_ahead_id = 5)
    update_signal(3, sig_ahead_id = 4)
    update_signal(2, sig_ahead_id = 3)
    update_signal(1, sig_ahead_id = 2)
        
    return()

#------------------------------------------------------------------------------------
# This is where the code begins
#------------------------------------------------------------------------------------

# Create the Window and canvas
print ("Creating Window and Canvas")
window = Tk()
window.title("Simple Networking Example - Box1 (Pi Sprog Node)")
canvas = Canvas(window,height=400,width=1000,bg="grey85")
canvas.pack()

print ("Initialising Pi Sprog and creating DCC Mappings")
initialise_pi_sprog (dcc_debug_mode=False)
request_dcc_power_on()

# Signals 1,2,3,4 assume a TrainTech DCC 4 Aspect Signal - these are event driven
# and can take up to 4 consecutive addresses (if you include the flashing aspects)
# map_traintech_signal (sig_id = 1, base_address = 10)
# map_traintech_signal (sig_id = 2, base_address = 20)
# map_traintech_signal (sig_id = 3, base_address = 30)
# map_traintech_signal (sig_id = 4, base_address = 40)

print ("Initialising MQTT Client and connecting to external MQTT Message Broker")
# Configure the MQTT Broker networking feature to allow this application node to act as a remote
# DCC command station for other application nodes (i.e. forward received DCC commands to the Pi-Sprog) 
configure_networking(broker_host ="mqtt.eclipseprojects.io", network_identifier="network1",
                     node_identifier= "Box1",publish_dcc_commands=True, mqtt_enhanced_debugging=False )

# Subscribe to the external feed fo DCC commands from node 2
subscribe_to_dcc_command_feed("Box1")
set_signals_to_publish_state(1,10,11,12)
set_signals_to_publish_passed_events(2,10,11,12)
subscribe_to_signal_updates("Box1", main_callback_function,1,10,11,12)
subscribe_to_signal_passed_events("Box1", main_callback_function,2,10,11,12)
                     
print ("Drawing Schematic and creating points")
# Draw the the Top Main line
canvas.create_line(0,100,1000,100,fill="black",width=3) # Main Line

print ("Creating the track Occupancy Sections")
create_section (canvas,1,175,100,section_callback = main_callback_function)
create_section (canvas,2,425,100,section_callback = main_callback_function)
create_section (canvas,3,675,100,section_callback = main_callback_function)
create_section (canvas,4,925,100,section_callback = main_callback_function)

print ("Creating Signals")
create_colour_light_signal (canvas, 1, 50, 100,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = main_callback_function,
                            sig_passed_button = True,
                            refresh_immediately = False)
create_colour_light_signal (canvas, 2, 300, 100,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = main_callback_function,
                            sig_passed_button = True,
                            refresh_immediately = False)
create_colour_light_signal (canvas, 3, 550, 100,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = main_callback_function,
                            sig_passed_button = True,
                            refresh_immediately = False)
create_colour_light_signal (canvas, 4, 800, 100,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = main_callback_function,
                            sig_passed_button = True,
                            refresh_immediately = False)

create_colour_light_signal (canvas, 5, 50, 300,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_passed_button = True,
                            fully_automatic=True)

create_semaphore_signal (canvas, 10, 300, 300,
                            sig_callback = main_callback_function,
                            sig_passed_button = True)
create_ground_position_signal (canvas, 11, 550, 300,
                            sig_callback = main_callback_function,
                            sig_passed_button = True)
create_ground_disc_signal (canvas, 12, 800, 300,
                            sig_callback = main_callback_function,
                            sig_passed_button = True)

print ("Creating external Track Sensor Mappings")
# Map external track sensors for the signals - For simplicity, we'll give them the same ID as the signal
# We'll also map them to the associated "signal passed" events rather than using their own callback
create_track_sensor (1, gpio_channel = 4, signal_passed = 1)
create_track_sensor (2, gpio_channel = 5, signal_passed = 2)
create_track_sensor (3, gpio_channel = 6, signal_passed = 3)
create_track_sensor (4, gpio_channel = 7, signal_passed = 4)

print ("Entering Main Event Loop")
# Enter the main event loop and wait for a a callback event
window.mainloop()

#----------------------------------------------------------------------
# This programme provides an example of how to use the MQTT Networking functions
# to link different applications (representing different"signal boxes") together
# This is "Box2" - A remote node forwarding all DCC commands to "Box1"
# ---------------------------------------------------------------------

from tkinter import *
from model_railway_signals import *
import logging

#----------------------------------------------------------------------
# Configure the log level. If no 'level' is specified specified only warnings and errors
# will be generated. A level of 'INFO' will tell you what the various functions are doing
# 'under the hood' - useful when developing/debugging a layout signalling Scheme. A level
# of 'DEBUG' will additionally report the DCC Bus commands being sent to the Pi-SPROG and
# the messages being published to external nodes via the MQTT Broker
#----------------------------------------------------------------------

logging.basicConfig(format='%(levelname)s: %(message)s',level=logging.INFO)

# There is an additional level of debug logging that can be enabled for the MQTT interface
# This will show the log messages being generated by the Client for published/received messages
# Note that the main logging level also needs to be set to DEBUG to generate these messages

mqtt_debug = False

#----------------------------------------------------------------------
# This is the main callback function for the upper line
#----------------------------------------------------------------------

def upper_line_callback_function(item_id,callback_type):

    print ("Callback for upper line - Item: "+str(item_id)+" - Callback Type: "+str(callback_type))

    # We want the local Section 100 to mirror any changes made to Box1 Section 3
    # So we get an indication of the "next Train" that is going to enter our section
    if callback_type == section_callback_type.section_updated:
        if item_id == "Box1-3":
            if section_occupied ("Box1-3"):
                set_section_occupied(100,section_label("Box1-3"))
            else:
                clear_section_occupied(100)

    # Deal with changes to the Track Occupancy (based on signal events)
    if callback_type == sig_callback_type.sig_passed:
        if item_id == 1:
            set_section_occupied(1,section_label("Box1-3"))
        elif item_id == 2:
            set_section_occupied(2,clear_section_occupied(1))
        elif item_id == 3:
            clear_section_occupied(2)
            trigger_timed_signal(3,0,5)
            
    # Override signals based on track occupancy
    if section_occupied(1): set_signal_override(1)
    else: clear_signal_override(1)
    if section_occupied(2): set_signal_override(2)
    else: clear_signal_override(2)

    # Refresh the signal aspects based on the route settings
    # The order is important - Need to work back along the route
    update_signal(2, sig_ahead_id = 3)
    update_signal(1, sig_ahead_id = 2)
    
    return()

#----------------------------------------------------------------------
# This is the main callback function for the lower line
#----------------------------------------------------------------------

def lower_line_callback_function(item_id,callback_type):

    print ("Callback for lower line - Item: "+str(item_id)+" - Callback Type: "+str(callback_type))

    # Deal with changes to the Track Occupancy (based on signal events)
    if callback_type == sig_callback_type.sig_passed:
        if item_id == 10:
            set_section_occupied(10,clear_section_occupied(101))
        elif item_id == 11:
            set_section_occupied(11,clear_section_occupied(10))
        elif item_id == 12:
            set_section_occupied(12,clear_section_occupied(11))
        elif item_id == "Box1-11":
            clear_section_occupied(12)        
            
    # Override signals based on track occupancy
    if section_occupied(10): set_signal_override(10)
    else: clear_signal_override(10)
    if section_occupied(11): set_signal_override(11)
    else: clear_signal_override(11)
    if section_occupied(12): set_signal_override(12)
    else: clear_signal_override(12)

    # Update the state of Signal 112 (signal 12 distant arm) to "mirror"
    # the state of Box1 Signal 10 (on the remote network node
    if signal_state("Box1-10") == signal_state_type.PROCEED:
        if not signal_clear(112): toggle_signal(112)
    else:
        if signal_clear(112): toggle_signal(112)

    return()

#------------------------------------------------------------------------------------
# This is where the main code begins
#------------------------------------------------------------------------------------

# Create the Window and canvas
print ("Creating Window and Canvas")
window = Tk()
window.title("Simple Networking Example - Box2 (Remote node)")
canvas = Canvas(window,height=450,width=775,bg="grey85")
canvas.pack()

print ("Loading Layout State on startup")
# Configure the loading and saving of layout state. If file_name is 'None' then
# the name of the main python script will be used with a '.sig' extension
# For this example, the filename will be 'test_networking_1.sig'
load_layout_state(file_name=None,load_file_dialog=False,save_file_dialog=False)

print ("Creating DCC Mappings for Signals")
# Signals 1,2,3 assume a TrainTech DCC 4 Aspect Signal - these are event driven
# and can take up to 4 consecutive addresses (if you include the flashing aspects)
map_traintech_signal (sig_id = 1, base_address = 40)
map_traintech_signal (sig_id = 2, base_address = 50)
map_traintech_signal (sig_id = 3, base_address = 60)
# Signals 10,11,12 assume a single address mapping for the semaphore arms
map_semaphore_signal (sig_id = 10, main_signal = 104)
map_semaphore_signal (sig_id = 11, main_signal = 105)
map_semaphore_signal (sig_id = 12, main_signal = 106)

print ("Initialising MQTT Client and connecting to external Broker")
# Configure the MQTT Broker networking feature to allow this application node to act as a remote
# DCC command station for other application nodes (i.e. forward received DCC commands to the Pi-Sprog) 
configure_networking(broker_host ="mqtt.eclipseprojects.io", network_identifier="network1",
                     node_identifier= "Box2",publish_dcc_commands=True, mqtt_enhanced_debugging=mqtt_debug)
# Configure the upper line events/updates we want to publish/subscribe to
set_signals_to_publish_state(1)
set_signals_to_publish_passed_events(1)
subscribe_to_section_updates("Box1",upper_line_callback_function,3)
# Configure the lower line events/updates we want to publish/subscribe to
set_sections_to_publish_state(12)
subscribe_to_signal_updates("Box1",lower_line_callback_function,10)
subscribe_to_signal_passed_events("Box1",lower_line_callback_function,11)
                     
print ("Drawing Layout Schematic")
canvas.create_line(0,150,775,150,fill="black",width=3)
canvas.create_line(0,300,775,300,fill="black",width=3)
canvas.create_text (425,60,text="Signal 1 is configured to publish State Updates and Passed Events (to Box 1)")
canvas.create_text (425,80,text="State Updates from Box 1 Section 3 are used to provide an indication of the next train")
canvas.create_text (400,210,text="Section 12 is configured to publish State Updates (to Box1)")
canvas.create_text (400,230,text="Signal Passed Events from Box 1 Signal 11 are used to update update track occupancy")
canvas.create_text (400,250,text="Signal State Updates from Box 1 Signal 10 are used to update the Distant Arm of Signal 12")
canvas.create_text (375,400,text="The Distant Arm of Signal 12 mirrors\nthe distant arm of Box 1 Signal 10")
canvas.create_text (75,400,text="<<=== Box 1")

print ("Creating Track Occupancy Sections")
# Upper Line Sections
# Section 100 is a non editable section to "mirror" an external section
canvas.create_text (75,30,text="Next Train")
canvas.create_text (75,50,text="From Box1")
create_section (canvas,100,75,75,editable=False)
create_section (canvas,1,225,150,section_callback=upper_line_callback_function)
create_section (canvas,2,500,150,section_callback=upper_line_callback_function)
# Lower Line Sections
# Section 101 is an editable section to "set" the next approaching train
canvas.create_text (675,380,text="Right Click to")
canvas.create_text (675,400,text="Set Next Train")
create_section (canvas,101,675,425,section_callback=lower_line_callback_function)
create_section (canvas,10,575,300,section_callback=lower_line_callback_function)
create_section (canvas,11,325,300,section_callback=lower_line_callback_function)
create_section (canvas,12,75,300,section_callback=lower_line_callback_function)

print ("Creating Signals")
create_colour_light_signal (canvas, 1, 75, 150,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = upper_line_callback_function,
                            sig_passed_button = True,
                            refresh_immediately = False)
create_colour_light_signal (canvas, 2, 350, 150,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = upper_line_callback_function,
                            sig_passed_button = True,
                            refresh_immediately = False)
create_colour_light_signal (canvas, 3, 625, 150,
                            signal_subtype = signal_sub_type.four_aspect,
                            sig_callback = upper_line_callback_function,
                            sig_passed_button = True,
                            fully_automatic=True)
create_semaphore_signal (canvas, 10, 700, 300,
                        distant = True, orientation = 180,
                        sig_callback = lower_line_callback_function,
                        sig_passed_button = True)
create_semaphore_signal (canvas, 11, 450, 300, orientation = 180,
                        sig_callback = lower_line_callback_function,
                        sig_passed_button = True)
create_semaphore_signal (canvas, 12, 200, 300, orientation = 180,
                        sig_callback = lower_line_callback_function,
                        sig_passed_button = True)
create_semaphore_signal (canvas,112,200,300,
                         orientation = 180, distant = True,
                         fully_automatic = True,
                         associated_home = 12)

print ("Setting Initial Interlocking")
# Set the initial interlocking conditions by running the main callback function
upper_line_callback_function(None,None)
lower_line_callback_function(None,None)

print ("Entering Main Event Loop")
# Before we enter the main loop we need to force focus on the main TKinter window.
# I've had issues running the software on Windows platforms if you don't do this
window.focus_force()
# Now enter the main event loop and wait for a button press (which will trigger a callback)
window.mainloop()

#############################################################################################
